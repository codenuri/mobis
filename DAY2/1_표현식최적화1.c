// 92 page
int main()
{
	int day = 30;
	int a = 0, b = 0, c = 0, d = 0, x = 0;

	// 1. 상수를 모아라.
	// => 상수는 컴파일 시간에 연산이 가능합니다.
	// => 따라서, 상수끼리 모아 놓는 것이 효율적입니다.
//	int cnt1 = 60 * day * 24 * 31;  // bad. 그런데, 요즘은 이코드를 컴파일러가
	int cnt1 = day * 60 * 24 * 31;	// good  자동으로 이렇게 변경합니다.



	// 2. 표현식을 단순하게.
	// => 아래 2줄은 완전히 동일한 코드 입니다.
	// => ax^3 + bx^2 + cx + d
	int y1 = a * x * x * x + b * x * x + c * x + d;  // 6번의 곱셈, 3번의 덧셈
	int y2 = (((a * x + b) * x + c) * x + d);		 // 3번의 곱셈, 3번의 덧셈




	// 3. increment 
	int n1 = ++a; 	// 				 a += 1; return a;
	int n2 = b++; 	// int temp = b; b += 1; return temp;
					// ^ 이 부분이 추가됩니다. 
					// 따라서 전위형 ++이 후위형 보다 빠릅니다.

	// 반환값을 사용하지 않고 단순히 1증가 목적이라면
	++n1;	// good
	n1++;	// bad	<= 요즘은 이경우도 "반환값을 사용하지 않으면"
			//			컴파일러가 전위형으로 변경. 

	for (int i = 0; i < 10; ++i ) // good
	for (int i = 0; i < 10; i++ ) // bad 라고 했었지만, 요즘은 가독성 측면에서 
									// 이 코드를 권장하기도 함. 컴파일러 최적화 지원
	{						
	}
	// 단, C++ 의 사용자 정의 타입(반복자 같은)을 ++ 하는 것은
	// => 전위형이 빠릅니다.
}

